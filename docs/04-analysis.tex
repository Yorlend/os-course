\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с техническим заданием, требуется написать драйвер сканера отпечатка пальца Shenzhen Goodix Technology \cite{goodix} для операционной системы Linux.

Для решения поставленной задачи необходимо:

\begin{itemize}[label=---]
    \item проанализировать особенности работы сканера отпечатка пальца;
    \item рассмотреть способы получения данных от устройства с использованием подсистемы USB \cite{USB};
    \item разработать драйвер в виде загружаемого модуля ядра;
    \item провести исследование разработанного драйвера.
\end{itemize}

\section{Конфигурация устройства}

Ниже приведена конфигурация устройства, полученная из отладочной файловой системы по пути \texttt{/sys/kernel/debug/devices} \cite{sysfs}.

\begin{verbatim}
T:  Bus=03 Lev=01 Prnt=01 Port=03 Cnt=01 Dev#=  2 Spd=12   MxCh= 0
D:  Ver= 2.00 Cls=02(comm.) Sub=01 Prot=01 MxPS=64 #Cfgs=  1
P:  Vendor=27c6 ProdID=5125 Rev= 2.00
S:  Manufacturer=Shenzhen Goodix Technology Co.,Ltd.
S:  Product=Goodix Fingerprint Device
S:  SerialNumber=00000000001A
C:* #Ifs= 2 Cfg#= 1 Atr=60 MxPwr=100mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=02(comm.) Sub=01 Prot=01 Driver=(none)
E:  Ad=82(I) Atr=03(Int.) MxPS=   8 Ivl=16ms
I:* If#= 1 Alt= 0 #EPs= 2 Cls=0a(data ) Sub=00 Prot=00 Driver=(none)
E:  Ad=01(O) Atr=02(Bulk) MxPS=  64 Ivl=0ms
E:  Ad=81(I) Atr=02(Bulk) MxPS=  64 Ivl=0ms
\end{verbatim}

Данное устройство имеет одну конфигурацию с двумя активными интерфейсами, первый из которых предназначен для передачи управляющих комманд, а второй -- для передачи данных.

\section{Подсистема USB}

USB драйвер имеет две точки входа -- \texttt{probe} и \texttt{disconnect} \cite{usb-driver}, которые вызываются подсистемой USB при подключении и отключении устройства, соответствующего данному драйверу.

Обмен информацией между подключенным устройством и драйвером осуществляется пакетами по запросу. Блок запроса USB (USB Request Block -- URB) представляется структурой ядра \texttt{urb}:

\begin{small}
\begin{verbatim}
struct urb {
    struct list_head urb_list;
    struct usb_device *dev; /* (in) pointer to associated device */
    unsigned int pipe; /* (in) pipe information */
    int status; /* (return) non-ISO status */
    void *transfer_buffer; /* (in) associated data buffer */
    dma_addr_t transfer_dma; /* (in) dma addr for transfer_buffer */
    u32 transfer_buffer_length; /* (in) data buffer length */
    u32 actual_length; /* (return) actual transfer length */
    int interval; /* (modify) transfer interval */
    void *context; /* (in) context for completion */
    usb_complete_t complete; /* (in) completion routine */
    /* ... */
};
\end{verbatim}
\end{small}

\subsection{Способы передачи URB пакетов}

Передача URB пакетов по шине USB является дуплексной и может происходить в одной из четырех форм, в зависимости от подключенного устройства:

\begin{itemize}[leftmargin=1.6\parindent]
    \item[---] \texttt{Control} -- используется для передачи управляющих команд для настройки устройства или получения его статуса.
    \item[---] \texttt{Bulk} -- используется для обмена большими пакетами данных. Зачастую именно эта форма передачи используется устройствами на подобие сканеров и SCSI адаптеров.
    \item[---] \texttt{Interrupt} -- используется для запроса передачи небольших пакетов в режиме опроса устройства. Если был запрошен пакет в режиме прерывания, то драйвер хост-контроллера автоматически будет повторять этот запрос с определенным интервалом (1--255 мс).
    \item[---] \texttt{Isochronous} -- используется для передачи данных в реальном времени с гарантированной пропускной способностью шины, но ненадежно. В общем случае изохронный тип используется для передачи аудио и видео информации. 
\end{itemize}

Рассматриваемое устройство -- сканер отпечатка пальца -- поддерживает форматы передачи \texttt{Control} (для передачи управляющих команд) и \texttt{Bulk} (для передачи изображения считанного отпечатка пальца).

\section{Особенности взаимодействия с устройством с использованием протокола TLS}

Сканер отпечатков пальцев Shenzhen Goodix Technology для Linux требует использования протокола TLS \cite{tls} 1.2 для защиты передачи данных.

Для аутентификации в данном протоколе используются асимметричные алгоритмы
шифрования \cite{encryption} (открытый ключ -- закрытый ключ), а для сохранения конфиденциальности --
симметричные (с одним, секретным, ключом), также используются и сеансовые ключи, которые
необходимы для каждого отдельного уникального защищенного сеанса.

В соответствии с протоколом TLS процесс инициации сеанса, также называемый <<рукопожатием>>, состоит из следующих шагов:

\begin{enumerate}
    \item Клиент (в данном случае -- драйвер) отправляет запрос на безопасное соединение с сервером (устройством).
    \item Сервер предоставляет цифровой сертификат, подтверждающий подлинность сервера.
    \item Используя открытый ключ сервера, клиент и сервер устанавливают сеансовый ключ, с помощью которого шифруются данные на протяжении всего сеанса.
\end{enumerate}

Установка защищенного соединение с устройством производится через отправку URB Control блоков.

\section{Взаимодействие драйвера с пользовательскими программами}

Одним из возможных способов передачи информации из пространства ядра в пространство пользователя является использование виртуальной файловой системы proc \cite{vfs-proc}.

Операции, которые могут быть осуществлены с файлом определяются структурой \texttt{proc\_ops}. В данной работе необходимо и достаточно реализовать следующие операции: \texttt{proc\_open}, \texttt{proc\_read}, \texttt{proc\_lseek}, \texttt{proc\_poll}, \texttt{proc\_release}.

Так как изображение отпечатка пальца имеет существенный размер, пользовательское приложение может не обработать все данные за одну операцию чтения.
В ядре Linux есть интерфейс файлов последовательностей (sequence file).
Использование данного интерфейса избавляет разработчика загружаемого модуля ядра от необходимости учитывать описанную проблему.


В случае, если пользователь не прикладывает палец к сканеру, процесс должен быть заблокирован при попытке чтения. Необходимость блокировки процесса и ожидания появления нового события приводит к использованию очередей ожидания, которые представляются в ядре структурой \texttt{wait\_queue\_head}:

\begin{small}
\begin{verbatim}
struct wait_queue_entry {
    unsigned int flags;
    void *private;
    wait_queue_func_t func;
    struct list_head entry;
};

struct wait_queue_head {
    spinlock_t lock;
    struct list_head head;
};
\end{verbatim}
\end{small}

Блокировка процесса и ожидание возникновения события осуществляется вызовом макроса

\texttt{wait\_event\_interruptible(wq\_head, condition)}.

Все ждущие в данной очереди процессы пробуждаются посредством вызова макроса \texttt{wake\_up\_all(wq\_head)}, после чего будет анализировано выражение \texttt{condition} переданное при блокировке. Если оно ложно, то процесс вновь блокируется.

Для поддержки механизма опроса реализуется функция \texttt{proc\_poll}.

\subsection*{Выводы}

В данном разделе была представлена конфигурация устройства сканера, изложены основные моменты работы с подсистемой USB при проектировании драйверов USB-устройств в ОС Linux. Также рассмотрены особенности взаимодействия драйвера с устройством с использованием протокола TLS и обеспечением защищенного соединения. Обсуждены способы передачи данных из пространства ядра в пространство пользователя.

